{"name":"Vfr","tagline":"Auto Chapter & QPFile creator and Audio cutter for VFR video","body":"vfr.py\r\n======\r\n\r\nInspired on: Daiz's AutoMKVChapters, TheFluff's split_aud, BD_Chapters\r\n\r\nNeeds: Python 3; MkvToolNix (for audio trimming)\r\n\r\nWhat it does\r\n------------\r\n\r\n* Reads the first line of uncommented Trims from an .avs;\r\n* Uses timecodes files to get each trim's frame's timestamp;\r\n* Offsets the trims accordingly;\r\n* Creates a basic xml with Matroska chapters, x264 chapters if ending in 'x264.txt' or OGM chapters if any other extension is used;\r\n* Creates a qpfile to use with x264;\r\n* Cuts and merges audio (as per split_aud, only using v2 timecodes instead of expecting cfr) (all options work as split_aud);\r\n* No longer needs tcConv but converts v1 timecodes to v2 internally;\r\n* If requested, can output v2 timecodes from v1 and fps parsing. If --ofps is being used, v2 timecodes will use it;\r\n* Can output a qpfile with converted frames meant to be used for an ivtc'd encode using non-ivtc'd frames (feature inspired by automkvchapters) (not completely accurate, obviously);\r\n* Using FFmpegsource's CorrectNTSCRationalFramerate, this is actually more precise in the v2 timecodes it produces than tcConv;\r\n* Accepts AutoMKVChapters-like templates.\r\n\r\nOnly the .avs with trims is required for vfr.py to run. You can use -v and/or --test to debug the script. All other options and arguments are optional.\r\n\r\nUsage\r\n-----\r\n\r\nvfr.py -i audio.aac -o audio.cut.mka -f 30/1.001 -l tRim -c chapters.xml -t template.txt \\\r\n-n chnames.txt -q qpfile.qpf -vmr --ofps 24/1.001 --timecodes v2.txt --test trims.avs outtrims.avs\r\n\r\nRequired:\r\ntrims.avs = Gets first uncommented line starting with trims from this Avisynth script\r\n\r\nOptional:\r\n<pre>-i = Audio to be cut (takes whatever mkvmerge takes)\r\n-o = Cut audio inside .mka\r\n    Default: input.cut.mka\r\n-d = Manually set delay time for input audio (can be negative)\r\n-b = Reverse parsing of .avs (from bottom to top)\r\n-f = Frames per second or timecodes file if vfr input\r\n    (takes \"25\", \"24000/1001\", \"30000:1001\", \"24/1.001\" and \"30:1.001\" as cfr input)\r\n    Default: 30000/1001\r\n-l = Look for a line starting with a case-sensitive trim() or case-insensitive comment succeeding the trims, interpreted as a regular expression.\r\n    Default: case insensitive trim\r\n-g = Specify directly the line used\r\n-c = Chapters file. If extension is 'xml', outputs MKV Chapters;\r\n    if extension is 'x264.txt', outputs x264 Chapters; else, outputs OGM Chapters\r\n-n = Text file with chapter names, one per line; assumed to be UTF-8 without BOM\r\n-q = QPFile for use in x264; will use --ofps frames\r\n-t = Template file for advanced Matroska chapters\r\n-v = Verbose mode\r\n-m = Merge split audio files\r\n-r = Remove split audio files after merging\r\n--uid = Set base UID for --template/--chnames\r\n--chnames = Path to basic text containing chapter titles separated by newlines\r\n--ofps = Output FPS (used in qpfile, v2 timecodes and avs export)\r\n    Default: -f\r\n--timecodes = Output v2 timecodes (from fps and v1 parsing) (if using --ofps, outputs v2 timecodes using this)\r\n--sbr = Set this if inputting an .aac and it's SBR/HE-AAC\r\n--test = Test Mode (doesn't create new files)\r\n    outtrims.avs = If chapparse.py is present, outputs .avs with offset and converted trims</pre>\r\n\r\nTo do:\r\n* Optimize code and/or improve its legibility\r\n\r\nKnown issues:\r\n* Conversion from a different input fps to output fps is not accurate (probably no way it can ever be fixed)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}